/* File:		TaskWrapper.m Description: 	This is the implementation of a generalized process handling class that that makes asynchronous interaction with an NSTask easier.  Feel free to make use of this code in your own applications.  TaskWrapper objects are one-shot (since NSTask is one-shot); if you need to run a task more than once, destroy/create new TaskWrapper objects.  */#import "TaskWrapper.h"@implementation TaskWrapper	// Do basic initialization- (id)initWithController:(id <TaskWrapperController>)cont 					with:(NSString *)launchPath 				 options:(NSMutableArray*)cmdlineOptions 				encoding:(NSStringEncoding)anEncoding 			   useStdout:(BOOL)useout{	self = [super init];	controller = cont;	taskLaunchPath = launchPath;	arguments = [cmdlineOptions retain];	currentEncoding = anEncoding;	useStdOut = useout;        return self;}	// tear things down- (void)dealloc{    [self stopProcess];    [arguments release];    [task release];    [super dealloc];}	// Here's where we actually kick off the process via an NSTask.- (void) startProcess:(NSString*)textInput{    [controller processStarted];		// make pipes & hook them up    task = [[NSTask alloc] init];		NSData *dataIn;		@try {		dataIn = [textInput dataUsingEncoding: currentEncoding];	}	@catch (NSException *e) {		NSLog(@"exc! %@", e);			//		[self alertCriticalException:e];		return;	}		NSLog(@"In: %@", dataIn);		NSPipe *toPipe = [NSPipe pipe];	NSPipe *fromPipe = [NSPipe pipe];	NSPipe *errPipe = [NSPipe pipe];	NSFileHandle *writing = [toPipe fileHandleForWriting];	if (useStdOut) {		reading = [fromPipe fileHandleForReading];	}	else {		reading = [errPipe fileHandleForReading];			}		[task setStandardInput:toPipe];	[task setStandardOutput:fromPipe];	[task setStandardError:errPipe];	[task setArguments:arguments];	[task setLaunchPath:taskLaunchPath];	    [[NSNotificationCenter defaultCenter] addObserver:self 											 selector:@selector(getData:) 												 name:NSFileHandleReadCompletionNotification 											   object:reading];    [reading readInBackgroundAndNotify];    [task launch];		[writing writeData:dataIn];	[writing closeFile]; // grab text of doc and write it}	// If the task ends, there is no more data coming through the file handle even when the notification is	// sent, or the process object is released, then this method is called.- (void) stopProcess{    NSData *data;    	[[NSNotificationCenter defaultCenter] removeObserver:self name:NSFileHandleReadCompletionNotification object: reading];    	[task terminate]; // Make sure the task has actually stopped!	while ((data = [reading availableData]) && [data length])	{		[controller appendOutput: [[NSString alloc] initWithData:data encoding:currentEncoding]];	}		[controller processFinished];	controller = nil;}	// This method is called asynchronously when data is available from the task's file handle.	// We just pass the data along to the controller as an NSString.- (void) getData: (NSNotification *)aNotification{    NSData *data = [[aNotification userInfo] objectForKey:NSFileHandleNotificationDataItem];		// If the length of the data is zero, then the task is basically over - there is nothing more to get from the handle so we may as well shut down.    if ([data length]) {		[controller appendOutput: [[NSString alloc] initWithData:data encoding:currentEncoding]];    } else {        [self stopProcess];    }    [[aNotification object] readInBackgroundAndNotify];  }@end